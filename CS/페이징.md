# 페이징을 통한 가상 메모리 관리

연속 메모리할당은 외부 단편화, 물리메모리보다 큰 프로세스 실행 불가라는 문제점을 가지고 있다.

위의 문제점은 가상 메모리 기술을 사용하여 해결할 수 있다. 가상메모리란 실행하고자 하는 프로그램의 일부만 메모리에 적재하여 실제 물리 메모리보다 큰 프로세스를 실행할 수 있도록 하는 기술을 말한다.

가상 메모리 기법에는 페이징과 세그먼테이션 등이 있다.

<br>

## 페이징

<br>

페이징은 프로세스의 논리 주소공간을 페이지라는 일정 단위로 나눈 후, 메모리의 물리 주소 공간을 프레임이라는 페이지와 동일한 일정한 단위로 자른뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.

그렇기 때문에 모든 프로세스는 페이징을 통해 모두 같은 크기를 유지하게 되고, 프로세스를 메모리에 적재,삭제 하는 과정에서 외부 단편화가 발생하지 않게 된다.

하지만 페이징을 사용하면 또다른 문제가 발생할 수 있는데 그것은 바로 내부 단편화이다. 이는 모든 프로세스의 크기가 페이지의 배수가 되는것이 아니기 때문에 프로세스의 마지막 조각보다 작은 데이터가 담겨 사용할 수 없는 공간이 생기는 현상을 말한다.

페이징에서 스와핑을 사용할 수 있으며 프로세스 단위의 스왑 인(페이지 인),아웃(페이지 아웃) 이 아닌 페이지 단위의 스왑인,아웃을 통해 실행에 필요한 페이지들을 메모리에 적제하고, 실행에 필요하지 않는 페이지들을 메모리에서 보조기억장치로 옮기게 된다.

페이징을 사용하게 되면 프로세스를 실행시키기 위해 모든 페이지가 적제될 필요가 없다. 즉 메모리보다 큰 프로세스도 정상실행할 수 있게된다.

페이징을 사용할경우 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 순서가 없기 때문에 일일이
알고 있기란 어렵다.

또한 불연속적으로 배치되어 있기때문에 cpu 입장에서는 이를 순차적으로 cpu입장에서는 다음에 실항할 명령어 위치를 찾기가 어려워 진다. 

<br>

## 페이지 테이블

<br>

이를 해결하기 위해서 페이지 테이블을 사용한다. 페이지 테이블이란 실제 메모리 내의 주소에 불연속적으로 배치되더라도, 논리 주소에는 연속적으로 배치되도록 하는 방법이며 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표역할을 한다고 할 수 있다.

프로세스마다 페이지 테이블이 존재하며, 각 페이지 테이블은 cpu내의 프로세스 테이블 베이스 레지스터를 줄여 RTBR이라 한다.

페이지 테이블이 만약 메모리상에 적재되어 있다고 가정할 경우에는 메모리 접근하는 시간이 두배로 걸리게 된다. 페이지 테이블 참조하기 위해 한번, 페이지 참조하기 위해 한번.

이를 피하기 위해 페이지 테이블은 메모리가 아닌 TLB라는 캐시메모리에 적재된다. TLB에는 페이지 테이블의 일부가 저장된다.

cpu가 접근하려는 논리주소가 TLB에 있다면 TLB 히트라고 하며 메모리에 접근하는 횟수는 한번이 된다. cpu가 접근하려는 논리주소가 TLB에 없다면 TLB 미스라고 하며 메모리에 접근하는 횟수는 두번이 된다.

<br>

## 페이징에서 주소변환

<br>

특정 주소에 접근하고자 한다면 어떤 페이지나 프레임에 접근하고 싶은지, 접근하려는 주소가 그 페이즈 혹은 프레임으로부터 얼마나 떨어져 있는지 정보가 필요하다. 

페이징 시스템에서의 논리주소는 페이지 번호와 변위로 이루어져 있다.  

페이지 번호와 변위로 이루어져 있는 논리 주소는 페이지 테이블을 통해 프레임 번호와 변위로 이루어진 물리주소로 변환된다.

<br>

## 페이지 테이블 엔트리

<br>

페이지 테이블의 각각의 행을 페이지 테이블 엔트리(PTE)라고 하며 현재 언급된 페이지 번호, 프레임번호를 제외하고도 담기는 정보가 존재한다. 이는 운영체제마다 상이하며 대중적인 정보는 다음과 같다.

<br>

### 1. 유효비트

<br>

유효비트란 현재 해당 페이지에 접근 가능여부를 표현하는 정보이다. 즉 해당 페이지가 메모리상에 적재되어있는지 보조기억장치에 저장되어있는지 여부로 인해 접근가능 여부를 나타내는 정보를 담고 있다. 1은 해당 페이지가 메모리에 저장되어 있어 접근이 가능하다는 의미이며, 0은 해당 페이지가 보조기억장치에 저장되어 있어 현재 접근하지 못한다는 의미를 가지고 있다. 

유효비트가 0인 페이지에 접근하려하면 페이지폴트(page fault)라는 인터럽트가 발생한다.

페이지 폴트 인터럽트가 발생하면 보조기억장치에 있는 해당 페이지를 메모리에 적재시킨다음 유효비트를 1로 변경시켜 접근가능하게 변경하고 cpu는 해당 페이지를 접근하는 절차를 따른다.

<br>

### 2. 보호비트

<br>

보호비트란 페이지 보호기능을 위해 존재하는 비트를 말하며 특정 페이지가 읽기전용페이지 인지, 읽기/쓰기가 가능한 페이지 인지 상태를 저장한다.

<br>

### 3. 참조비트

<br>

참조비트는 cpu가 해당 페이지가 메모리에 적재된 이후에 접근한 적이 있는지 여부를 저장한 정보를 말하며, 특정 페이지에 cpu가 접근한 적이 없다면 값은 0이된다.

<br>

### 4. 수정비트

<br>

cpu가 특정 페이지에 데이터를 쓴 적이 있는지 여부를 저장한 정보를 말한다. 즉 메모리에 적재된 이후 페이지가 수정된 적이 있다면 값은 1이 된다.
                  
<br>

--- 

<br>

### 참조

<br>

[강의] [개발자를 위한 컴퓨터공학 1: 혼자 공부하는 컴퓨터 구조+운영체제](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

