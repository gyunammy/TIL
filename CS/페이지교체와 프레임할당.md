# 페이지 교체와 프레임 할당

페이징을 통해 물리 메모리보다 큰 프로세스를 실행 할수 있지만 그럼에도 물리 메모리의 크기는 한정되어 있다.

따라서 한정적인 물리 메모리를 효율적으로 사용하기 위해서 기존에 적재된 불필요한 페이지를 보조기억장치로 이동시켜 공간을 확보하고, 추가적으로 프로세스들에게 적절한 프레임을 할당해야 한다.

<br>

## 요구 페이징 

<br>

처음부터 모든 페이지를 적재하지 않고 필요한 페이지만 메모리에 적재하는 기법, 즉 요구되는 페이지만 적재하는 기법을 말한다.

<br>

1. cpu가 특정 페이지에 접근하는 명령어를 실행한다.
2. 해당 페이지가 현재 메모리에 있을경우 (유효 비트가 1일 경우) cpu는 페이지가 적재된 프레임에 접근한다.
3. 해당 페이지가 현재 메모리에 없을 경우 (유호 비트가 0일 경우) 페이지 폴트가 발생한다.
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효비트를 1로 설정한다.
5. 다시 1번을 수행한다.

<br>

요구페이징 시스템이 안정적으로 작동하려면 페이지 교체와 프레임할당 문제가 해결되어야 한다.

<br>

### 페이지 교체 알고리즘

<br>

요구페이징 기법으로 페이지들을 적재하다보면 언젠간 메모리가 가득 차게된다. 이때
당장 실행에 필요한 페이즈를 적재할면 적재된 페이지를 보조기억장치로 내보내야 하는데 이때 어떤 페이지를 내보내는지 결정하는 알고리즘이 바로 페이지 교체 알고리즘이다.

좋은 페이지 교체 알고리즘이란 페이지 폴트가 적게 나타나는 알고리즘을 말한다. 페이지 폴트가 발생하면 보조기억장치에 접근해야 해서 성능이 저하된다.

따라서 페이지 교체 알고리즘의 성능을 확인하기 위해서는 페이지 폴트 횟수를 확인할 수 있어야 한다. 그러기 위해서는 페이지 참조열을 사용한다. 페이지 참조열이란 cpu가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열을 말한다.

```
2223555337  ->  23537
```

<br>

### 페이지 교체 알고리즘

<br>

#### 1. FIFO 알고리즘 (First In Frist Out)

<br>

가장 단순한 방식으로서 메모리에 먼저 들어온 페이지를 먼저 내보내는 방식이다.

FIFO 알고리즘의 단점으로는 프로그램 실행 내내 사용되는 페이지가 존재하기 때문에 먼저 적재되었다는 이유로 사용되어야하는 페이지가 내보내질 수 있다는 점이다.

이를 해결하기 위해 FIFO 알고리즘을 변형시킨 알고리즘이 있는데 이를 2차 기회 페이지 교체 알고리즘이라 한다.

2차 기회 페이지 교체 알고리즘도 FIFO 알고리즘과 같이 먼저 적재된 페이지를 먼저 내보내는 방식을 따르지만 페이지 교체를 할때 해당 페이지의 참조비트를 확인하여 1일 경우 즉, cpu가 한번 참조한 적이 있는 페이지는 참조비트를 0으로 변경후 적재된 시간을 최신으로 변경한다. 

참조비트가 0일 경우 즉, cpu가 참조한 적이 없는 페이지일 경우에는 내보내는 과정을 거치게 된다.

<br>

#### 2. 최적 페이지 교체 알고리즘

<br>

최적 페이지 교체 알고리즘이란 cpu에 의해 참조되는 횟수를 고려하는 알고리즘이다.
메모리에 오래 남아야 할 페이지는 자주 사용될 페이지이고 반대로 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지 이다.

이를 바탕으로 최적 페이지 교체 알고리즘은 앞으로 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘이다.

최적 페이지 교체 알고리즘은 최소의 페이지 폴트를 보장하는 페이지 교체 알고리즘이다. 이 알고리즘은 앞으로 사용되지 않을 페이지를 예측하기가 어렵기 때문에 실제 구현이 어렵다.

따라서 다른 페이지 교체 알고리즘 성능을 평가하기 위한 척도로서 이론적인 방식으로 사용된다. 

<br>

#### 3. LRU(Least-Recently-Used) 페이지 교체 알고리즘

<br>

LRU 알고리즘은 최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을까 하는 예측을 구현한 알고리즘이다. 즉 가장 오래 사용되지 않은 페이지를 우선적으로 교체하는 알고리즘이다.

<br>

### 스레싱

<br>

프로세스가 실행되는 시간보다 페이징 교체에 더 많은 시간을 소요하여 cpu이용률이 낮은, 즉 성능이 저해되는 문제를 스레싱이라고 한다.

동시실행되는 프로세스의 수와 cpu 이용률은 비례하지 않다. 즉 동시실행되는 프로세스가 많아짐에 따라 cpu 이용률 또한 비례하여 높아질것 같지만 어느 지점에 도달하게 되면 스레싱으로 인해 cpu이용률은 감소하게 된다.

스레싱이 발생하는 이유는 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문이다. 스레싱을 방지하기 위해서는 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해주어야 한다.

<br>

### 프레임 할당 방법

<br>

#### 1. 균등 할당

<br>

가장 단순한 프레임 할당방식으로서 모든 프로세스들에게 균등하게 프레임을 할당하는 방식이다.

균등 할당은 프로세스의 크기를 고려하지않는 방식이기 때문에 비효율적이다.

<br>

#### 2. 비례 할당

<br>

프로세스의 크기를 고려하여 프레임을 할당하는 방식으로 프로세스 크기에 비례하여 프레임을 할당하는 방식이다.

프로세스의 크기와 요구프레임 수는 비례하지 않기 때문에 결국 해당 프로세스가 필요로 하는 프레임 수는 실행해봐야 확인할 수 있다.

균등할당과 비례할당은 프로세스의 실행과정을 고려하지 않고, 프로세스의 크기나 물리메모리의 크기만들 고려하기 때문에 정적 할당 방식이라고도 부른다.

<br>

#### 3. 작업 집합 모델

<br>

프로세스가 실행하는 과정에서 배분할 프레임을 결정하는 방식이다. 

스레싱이 발생하는 이유는 빈번한 페이지 교체 때문이다. 이를 해결하기 위해
cpu가 특정시간동안 주로 참조한 페이지 개수만큼 프레임을 할당하는 방식이다. 

프로세스가 일정기간 동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지힌다.

작업집합이란 실행중인 프로세스가 일정 시간 동안 참조한 페이지의 집합을 말한다.

작업집합을 구하기 위해서는 프로세스가 참조한 페이지와 시간 간격을 알아야 한다.

<br>

#### 4. 페이지 폴트 빈도

<br>

프로세스가 실행하는 과정에서 배분할 프레임을 결정하는 방식이다.

페이지 폴트율이 낮다면 프로세스의 요구 프레임에 비해 많은 프레임을 할당하였다는 의미이고 반대로 페이지 폴트율이 높다면 프로세스의 요구 프레임에 비해 적은 프레임을 할당하였다고 판단한다.

즉, 페이지 폴트율에 적정선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식을 말한다.

작업 집합 모델과 페이지 폴트 빈도는 모두 프로세스가 실행하는 과정을 관찰함으로서 적정 프레임을 할당하는 방식이기 때문에 동적 할당 방식이라고도 부른다.

<br>

--- 

<br>

### 참조

<br>

[강의] [개발자를 위한 컴퓨터공학 1: 혼자 공부하는 컴퓨터 구조+운영체제](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

